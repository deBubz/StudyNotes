# Plan for submission vid

## prep

- vscode ide with 3 files created
- `vertex.hpp` precopied
- `dg.hpp` blank copy first
- `dg.cpp` copy second

## talking points

- header file
  - talk about your extra design
  - grouping private elements in the bottom, mainly to hide recursive methods from users, less user error
  - added an extra `tree_root` to keep the vertex id of the graph
  - on hindsight i should have kept a seperate private scope for the class fields on top
- constructors
  - basic constructor, destructor
  - extra constructor to keep track of tree root,
  - the thought was its used to keep track of root and determine the graph is a tree or not
- helper functions
  - **contains** for `maps.find(key)` returns `map.end()` if keys not found
  - **adjacent** talk about adjacency list, checks for existing vertices, no looped edges
    - works the same as contains, but with this is a maps of maps for adjlist,
    - used `u_id` go get the set of maps containing `v_id` and edge weight pair
- add functions
  - **vertex** has id/weight, check if it exist, if not added, to the list, increase count, adjlist
  - **edege** works the same as add_v, need to check for contains even if its already checked in adjacent
    - let say vertexes does not exist, this condition will be true and a then added a new edge into the graph
- remove functions
  - **vertex** check contains
    - removed from list, adj_list (removed all out edge)
    - remove in edges
  - **edge** self explanatory
    - dont need to check existing vertex, if they dont exist, nothing will happen
- degree
  - **in_degree** same approach as remove vertex, foreach vertex v, if theres an edge v->u,
    - -1 indicates the vertex u does not exist
  - **out_degree** tenary operator - short hand if statement
    - if exist returns the count of items in the maps of maps
    - else -1
  - **degree** total degree, sum of in and out
- get size: return the fields for `O(1)` when its need, slightly increases the space as theres 2 more fields in the graph object, but I dont have to iterate through the lists again to get a count.
- GET
  - **vertex** returns a vertex object based on u_id
  - **vertices** returns a vector of vertex using the vertex_list
- Neighbours
  - **first** neighbours, use the adj list
    - mistake on forgetting to use my own defined function
  - **second**
    - didnt figure out how to work with pointers effectively so theres alot of repeats of flags creation
    - 2nd order neighbours cant be itself
- traversals
  - Breadth first - travel through each level from the starting point
  - Depth first - travel to the deepest path first, then returns and visit branches
  - based both implementation on the iterative pseudo code in slide 5
    - BFT - queue
    - DFT - stack
- cylces
  - **reachable** if v is on the travel path from u, u can reach v.
  - **cycles** are travel path that starts and end at the same node
    - came up with the idea that, for any vertex u, if a neighbour v can reach u
    - its a cycle, starts from u->v-> ... ->u
    - after completing everything, I noticed that this is a terrible implementation for time complexity
- **out tree**
  - talk about how 1 param is not needed using my implementation
  - again visited-flag
  - used dft recursion
  - explain recursion params, tree to add, flag to check,
    - child is the visiting node, parent is the visiting from
- **DFT TRAVERSALS**
  - all the dft traversal types using similar dft
  - **PRE** the params are redundant?
    - since out_tree uses regular DFT recursive, its the same as this preorder traversal
  - **IN** since the tree wasn't require to be a binary tree
    - I have consider that, which is left or right, if the node has more than 2 branches
    - I just followed the pattern the path creates
  - **POST** follows the pattern
    - foreach loop  will not run if the list its iterating through has 0 elemetnts
      - add the node