# Hash Functions and basic ciphers

- **Cryptography** study of mathematical techniques related to the design of ciphers
- **Cryptanalysis** study of breaking them
- **Cryptology**(crypto) study of both cryptography and cryptanalysis

Crypto buiding blocks (cryptographic primitives)

- block ciphers
- stream ciphers
- digital signatures
- RNG

## Functions

- Function of `f : X -> Y` is defined by
  - domain, a set `X = {a,b,c}`
  - codomain, a set `Y = {x,y,z}`
  - rule `f` assigning each element of `X` to an element of `Y`
- Example let a function `f : {-1, 0, 1} -> {0, 1, 2}` defined by `f(x) = x^2`
  - f(-1) = 1
  - f(0) = 0
  - f(1) = 1

### Properties of Functions

- When `f : X -> y` is a function
- `f : {-1, 0, 1} -> {0, 1, 2}` where `f(x) = x^2`
  - The image of `x in X` (domain) is called `f(x)`, an element of `y` (codomain)
    - image of `f(-1)=1`, here `-1 is in X` and `1 is in Y`
  - The range of `f` is set of all images, and is a subset of `y`
    - the range of `f` is `{0,1}`
  - If `f(x) = y`, then `x` is called a pre image of `y` (inverse)
    - the preimaeg of `1` is `f^-1({1}) = {-1,1}`
    - preimage of `2` is `f^-1 ({2}) = {}`

### OneWay Functions

- Write `{0, 1}^1 -> {0, 1}^m` is one way if:
  - its *easy* to compute `f(x)` for all `x in X`
  - it is "computationally infeasible" to find a preimage
- **Intuitively**
  - given `x`, its easy to compute `f(x)`
  - given `f(x)` its hard to compute `x`
- **Data Encryption Standard Cipher** (DES)
  - `f(x) = DES(m, k) = c`
  - given `c` and `m`, it is difficult to find `k`

## Hash Funtions

- Hash function is an efficiently computable mapping of a string of anylength to a short fixed length string
- **Keyed Hash Functions**
- Some Hashed func take both a key(k) and a message(m)
  - **MAC(m) = h(m,k)**
- Two type used
  - Message Authentication codes(**MAC**)
  - Hash-based message authentication codes(**HMAC**)

### Props of secure Hash Functions

Not all hash functions are nessecarily secure. let `h: X -> Y` be a hash function, a secure hash must satisfy these properties:

- **Preimage Resistance** given `y` its hard to find preimage `x` in such `h(x) = y`
- **Second Preimage Resistance** given `x`, its hard to find `x' != x` in such `h(x') = h(x) = y`
- **Collsion Resistance** hard to find any pair of `x != x'` such that `h(x) = h(x')`

#### More properties

- **One way** hash satisfy
  - preimage resistance
  - second preimage resistance
- **collision resistant** hash satisfies
  - collision resistant (also satisfy second preimage resistance)

### Use of hash functions

> Useful for confimation of knowledge without revealing what you know

Say `A` and `B` know a secret, but they are not sure its the same

- **Solution** either `A` or `B` create a hash of the secret and send it to the other. The other will then compare it with their own created hash.
- If match the secret will be confirmed to be the same.

> Useful for storing passowrd

- Password are stored as a hash instead of plain text in the database.
- When a user tried to login, a calculated hash from the input is compared agaisnt the stored hash.
- If the Db is breached, the hash needs to be reversed before the attacker gets the password.

> Virus Protection & Host Intrusion Detection

- Foreach file `x`, `h(x)` is stored off system on a db
- periodically, system will calculate the hash for all files and check if matches with the ones stored in the database
- **seccond preimage resistance** is critical as it should be hard to find `x'` such that `h(x) = h(x')`

### Attacks on Hash

A subset of brute force is often used, **dictionary attack** were we throw subset of the key space(dictionaries) at the problem.

Brute force to attack preimage resistance:

- say a hash produces an `n-bit` output `h(x) = y`
- we must try `2^(n-1)` possibilities before the probability `Pr[h(a) = y] >= 0.5` where (a is an int)
- **e.g** if `a` is one of `2^10 = 1024` possibilities, you have to try half of them `2^9 = 512` on avg before you can find a match `y` such that `h(a) = y = h(x)` and therefor `a = x`

---

## Hash functions

### Iterated hash Construction

> slide 19 img

- `f` is a one- way compression function
- `hn` is the hash generated each step
- `IV` initialization vector
- Message `M` divided into `n` fixed bit blocks `mn`
- To maintain fixed block size, partial blocks pass through a padding function

### Key Hash Functions (MACs)

**Message Auth Codes** MACs are oneway hash function with the addtion of a key `hk: {1,0}* -> {0,1}^n`

The key is secreat and necessary to verify the hash `hk(m)` and can be thought of a crytographic checksum. Its Goals:

- Provides message authentication where sender and reciever share a secret
- An eavesdroper cannot fake a message with a vamid MAC.
- Used for message integrity, not message secrecy.

#### Properties of MACs

- Given `m` and `k` its easy to construct `hk(m)`
- Given pairs of messages and MAC `(mi, hk(mi))`
  - Its hard to construct a valid new pair `(mj, hk(mj))`
  - where `mj != mi` without knowledge of `k`

> MAC is `(e, ,t, q ,l)`
>
> Its secure if given `q` pars, each of length `<= l` in time `t` an advversary can suceed in constructing new (message, MAC) pairs with probability `< e`

Using macs over the network

- `A` and `B` share a secret key `k`
- uses MAC to verify shared data
- hacker tries if impersonate Alice and send message `m` to `B` containing malware along with the MAC using some key `k'` where `k != k'`
- Uppon recieving,`B` will calculate the MAC on the `m` using secret key `MAC(m) = hk(m)`
- `B` compares the calculated MAC with the recieved MAC and know that its wrong as `hk(m) != hk'(m)`
- Because the hacker does not have correct key `k`, so MAC generated by the attacker is not the same as generated by `B`

#### Constructing MACs

- Cryptographic
- Non-Keyed hash functions (HMAC) - fast
- block cypher (CBC-MAC) - slow
- Information Theoretic
- Based on universal hashing (outside of scope)

#### Hash Based MAC (HMAC)

MAC based on non-keyed hash func `h`

- **A1** `MACk(m) = h(k,m)`
  - Insecure: attacker can arbitrarily add to the end of the message (Merkle-Damgard cons)
- **A2** `MACk(m) = h(m,k)`
  - Insecure: vulnerable to birthday attack
- **A3** `MACk,k' (m) = h(k,m,k')`
  - More secure: enveloped method

Best: `MACk,k'(m) = h((k xor opad) + h(k xor ipad) + m))`

- **opad** is the outer padding
- **ipad** is the inner padding

#### Cipher-based MAC

CBC-MAC uses a technique known as cipher Block Chaining <br/>
Turn a message into blocks and repeat encryprion using a block cipher is XORer (+) <br>
Secret key = `(k, k', IV)`
